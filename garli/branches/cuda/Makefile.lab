
################################################################################
#
# Build script for project
#
################################################################################

# Add source files here
EXECUTABLE	:= GPUGarli0.96
# Cuda source files (compiled with cudacc)
CUFILES		:= cudainterface.cu
# C/C++ source files (compiled with gcc / c++)
CCFILES		:= \
	cudaman.cpp \
	condlike.cpp \
	datamatr.cpp \
	individual.cpp \
	population.cpp \
	rng.cpp \
	set.cpp \
	garlireader.cpp \
	topologylist.cpp \
	translatetable.cpp \
	tree.cpp \
	treenode.cpp \
	funcs.cpp \
	configreader.cpp \
	configoptions.cpp \
	bipartition.cpp \
	model.cpp \
	linalg.cpp \
	adaptation.cpp \
	sequencedata.cpp \
	optimization.cpp \
	garlimain.cpp \

################################################################################
# GARLI stuff

#(1) choose one of these compile types
#options are:
#gcc_any		gnu compiler gcc, any architecture
#gcc_osx_universal	gcc on OSX to make a universal binary
#xlc_ppc970		ibm compiler for Power PC 970 architecture
#icc_any		Intel compiler icc (commercial). icc code is much faster on intel hardware

COMPILE_TYPE = gcc_any


#(2) these need to be adjusted to the correct path to a compiled
#copy of Paul Lewis's Nexus Class Library
#(NCL is available here: http://hydrodictyon.eeb.uconn.edu/ncl)
#See the NCL documentation for details on compiling it.
#Note that you may be able to safely ignore some errors during
#NCL compilation (Garli only needs the static library libncl.a)
NCL_INCLUDES = /nfshomes/ayres/ncl-2.1.04/include/ncl
LIB_NCL = /nfshomes/ayres/ncl-2.1.04/lib/ncl/libncl.a

#(3)set this to yes to compile a version that uses MPI to fork
#multiple serial runs across processors (using the same config)
#This is an advanced option and should generally be = no unless
#you know what you are doing
MPI_RUN_SPLITTER = no

#gcc: gnu compiler 
	#linux or OSX binary that will work on the machine type that it is compiled on
ifeq ($(COMPILE_TYPE),gcc_any)
	GARLICC = g++
	GARLICC_FLAGS = -O3 -fstrict-aliasing -fomit-frame-pointer -funroll-loops \
		 -fsigned-char -DNDEBUG -DUNIX  -I$(NCL_INCLUDES)

endif

#gcc: gnu compiler 
	#OSX universal binary (may only compile on intel machines)
ifeq ($(COMPILE_TYPE),gcc_osx_universal)
	GARLICC = g++
	GARLICC_FLAGS = -O3 -fstrict-aliasing -arch i386 -arch ppc -fomit-frame-pointer \
		 -funroll-loops -DUNIX -DNDEBUG -include defs.h -I$(NCL_INCLUDES)
endif

#icc: intel compiler, any machine type
ifeq ($(COMPILE_TYPE),icc_any)
	GARLICC = icpc
	GARLICC_FLAGS =  -O2 -ip -fno-alias -DUNIX -DNDEBUG -I$(NCL_INCLUDES)
endif

#xlc: IBM compiler, PowerPC 970 processor
ifeq ($(COMPILE_TYPE),xlc_ppc970)
	GARLICC = xlC
	GARLICC_FLAGS = -qsourcetype=c++ -qarch=ppc970 -qtune=ppc970 -qenablevmx \
		-qaltivec -q64 -O3 -qalias=ansi -qunroll=yes -qchars=signed \
		-qinclude=defs.h -I$(NCL_INCLUDES) -DUNIX -DNDEBUG
endif

ifeq ($(MPI_RUN_SPLITTER), yes)
	GARLICC = mpicxx
	GARLICC_FLAGS += -DSUBROUTINE_GARLI
endif



################################################################################
#
# Common build script
#
################################################################################

.SUFFIXES : .cu .cu_dbg_o .c_dbg_o .cpp_dbg_o .cu_rel_o .c_rel_o .cpp_rel_o .cubin


CUDA_INSTALL_PATH ?= /nfshomes/ayres/cuda_64_rhel5/cuda

ifdef cuda-install
	CUDA_INSTALL_PATH := $(cuda-install)
endif

# detect OS
OSUPPER = $(shell uname -s 2>/dev/null | tr [:lower:] [:upper:])
OSLOWER = $(shell uname -s 2>/dev/null | tr [:upper:] [:lower:])
# 'linux' is output for Linux system, 'darwin' for OS X
DARWIN = $(strip $(findstring DARWIN, $(OSUPPER)))

# Basic directory setup for SDK
# (override directories only if they are not already defined)
SRCDIR     ?= src/
ROOTDIR    ?= .
ROOTBINDIR ?= bin
BINDIR     ?= $(ROOTBINDIR)/$(OSLOWER)
ROOTOBJDIR ?= obj
LIBDIR     := lib
COMMONDIR  := common

# Compilers
NVCC       := $(CUDA_INSTALL_PATH)/bin/nvcc 
CXX        := $(GARLICC)
CC         := gcc
LINK       := g++ -fPIC

# Includes
INCLUDES  += -I. -I$(CUDA_INSTALL_PATH)/include -I$(COMMONDIR)/inc

# architecture flag for cubin build
CUBIN_ARCH_FLAG := -m32

# Warning flags
CXXWARN_FLAGS := \
	-W -Wall \
	-Wimplicit \
	-Wswitch \
	-Wformat \
	-Wchar-subscripts \
	-Wparentheses \
	-Wmultichar \
	-Wtrigraphs \
	-Wpointer-arith \
	-Wcast-align \
	-Wreturn-type \
	-Wno-unused-function \
	$(SPACE)

CWARN_FLAGS := $(CXXWARN_FLAGS) \
	-Wstrict-prototypes \
	-Wmissing-prototypes \
	-Wmissing-declarations \
	-Wnested-externs \
	-Wmain \

# Compiler-specific flags
NVCCFLAGS := --ptxas-options=-v #-arch sm_13
#CXXFLAGS  := $(CXXWARN_FLAGS)
CXXFLAGS  += $(GARLICC_FLAGS)
CFLAGS    := $(CWARN_FLAGS)

# Common flags
COMMONFLAGS += $(INCLUDES) -DUNIX

# Debug/release configuration
ifeq ($(dbg),1)
	COMMONFLAGS += -g
	NVCCFLAGS   += -D_DEBUG
	BINSUBDIR   := debug
	LIBSUFFIX   := D
else 
	COMMONFLAGS += -O3 
	BINSUBDIR   := release
	LIBSUFFIX   :=
	NVCCFLAGS   += --compiler-options -fno-strict-aliasing
#	CXXFLAGS    += -fno-strict-aliasing
	CFLAGS      += -fno-strict-aliasing
endif


# architecture flag for cubin build
CUBIN_ARCH_FLAG := -m32

# Libs
LIB := -L$(CUDA_INSTALL_PATH)/lib -L$(LIBDIR) -L$(COMMONDIR)/lib/$(OSLOWER)
LIB += -lcudart ${OPENGLLIB} $(PARAMGLLIB) $(RENDERCHECKGLLIB) $(CUDPPLIB) ${LIB}
LIB += $(LIB_NCL)

#exe configuration
LIB += -lcutil$(LIBSUFFIX)

TARGETDIR := $(BINDIR)/$(BINSUBDIR)
TARGET    := $(TARGETDIR)/$(EXECUTABLE)
LINKLINE  = $(LINK) -o $(TARGET) $(OBJS) $(LIB)

# check if verbose 
ifeq ($(verbose), 1)
	VERBOSE :=
else
	VERBOSE := @
endif

################################################################################
# Check for input flags and set compiler flags appropriately
################################################################################

# workaround for mac os x cuda 1.1 compiler issues
ifneq ($(DARWIN),)
	NVCCFLAGS += --host-compilation=C
endif

# Add common flags
NVCCFLAGS += $(COMMONFLAGS)
CXXFLAGS  += $(COMMONFLAGS)
CFLAGS    += $(COMMONFLAGS)

ifeq ($(nvcc_warn_verbose),1)
	NVCCFLAGS += $(addprefix --compiler-options ,$(CXXWARN_FLAGS)) 
	NVCCFLAGS += --compiler-options -fno-strict-aliasing
endif

################################################################################
# Set up object files
################################################################################
OBJDIR := $(ROOTOBJDIR)/$(BINSUBDIR)
OBJS +=  $(patsubst %.cpp,$(OBJDIR)/%.cpp_o,$(notdir $(CCFILES)))
OBJS +=  $(patsubst %.c,$(OBJDIR)/%.c_o,$(notdir $(CFILES)))
OBJS +=  $(patsubst %.cu,$(OBJDIR)/%.cu_o,$(notdir $(CUFILES)))

################################################################################
# Set up cubin files
################################################################################
CUBINDIR := $(SRCDIR)data
CUBINS +=  $(patsubst %.cu,$(CUBINDIR)/%.cubin,$(notdir $(CUBINFILES)))

################################################################################
# Rules
################################################################################
$(OBJDIR)/%.c_o : $(SRCDIR)%.c $(C_DEPS)
	$(VERBOSE)$(CC) $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.cpp_o : $(SRCDIR)%.cpp $(C_DEPS)
	$(VERBOSE)$(CXX) $(CXXFLAGS) -o $@ -c $<

$(OBJDIR)/%.cu_o : $(SRCDIR)%.cu $(CU_DEPS)
	$(VERBOSE)$(NVCC) $(NVCCFLAGS) $(SMVERSIONFLAGS) -o $@ -c $<

$(CUBINDIR)/%.cubin : $(SRCDIR)%.cu cubindirectory
	$(VERBOSE)$(NVCC) $(CUBIN_ARCH_FLAG) $(NVCCFLAGS) $(SMVERSIONFLAGS) -o $@ -cubin $<


$(TARGET): makedirectories $(OBJS) $(CUBINS) Makefile
	$(VERBOSE)$(LINKLINE)

all : $(TARGET)

cubindirectory:
	$(VERBOSE)mkdir -p $(CUBINDIR)

makedirectories:
	$(VERBOSE)mkdir -p $(LIBDIR)
	$(VERBOSE)mkdir -p $(OBJDIR)
	$(VERBOSE)mkdir -p $(TARGETDIR)


tidy :
	$(VERBOSE)find . | egrep "#" | xargs rm -f
	$(VERBOSE)find . | egrep "\~" | xargs rm -f

clean : tidy
	$(VERBOSE)rm -f $(OBJS)
	$(VERBOSE)rm -f $(CUBINS)
	$(VERBOSE)rm -f $(TARGET)
	$(VERBOSE)rm -f $(NVCC_KEEP_CLEAN)

clobber : clean
	$(VERBOSE)rm -rf $(ROOTOBJDIR)

cudainterface.cu_o:  cudakernel.cu defs.h
cudaman.cpp_o:		 cudaman.h defs.h
condlike.cpp_o:      condlike.h defs.h
configreader.cpp_o:  configreader.h defs.h
configoptions.cpp_o: configoptions.h hashdefines.h  defs.h
tree.cpp_o:          tree.h hashdefines.h funcs.h defs.h clamanager.h
optimization.cpp_o:	 tree.h funcs.h defs.h
population.cpp_o:    population.h clamanager.h defs.h
individual.cpp_o:    individual.h clamanager.h defs.h
datamatr.cpp_o:      datamatr.h defs.h
model.cpp_o:         model.h defs.h
funcs.cpp_o:         funcs.h defs.h
linalg.cpp_o:        linalg.h defs.h
treenode.cpp_o:      treenode.h defs.h
bipartition.cpp_o:   bipartition.h defs.h
translatetable.cpp_o:translatetable.h defs.h
set.cpp_o:           set.h defs.h
rng.cpp_o:           rng.h defs.h
topologylist.cpp_o:  topologylist.h defs.h
adaptation.cpp_o:	 adaptation.h hashdefines.h defs.h
sequencedata.cpp_o:	 sequencedata.h defs.h
garlireader.cpp_o:	 garlireader.h defs.h

